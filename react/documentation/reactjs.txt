Reconciliation(согласование). Дерево React-элементов изменения в его узлах не переносятся
сразу на DOM-дерево, а создаётся новое изменённое и сравнивается с DOM-деревом
//

JSX — это расширение синтаксиса для JavaScript, которое позволяет вам описывать ваш 
пользовательский интерфейс с помощью знакомого HTML-подобного синтаксиса. 
///

//
Компонент - функция, которая возвращает JSX.

Жизненный цикл компонента (3 этапа):
	1. mount 2. update 3. unmout
//

3 правила Jsx: https://beta.reactjs.org/learn/writing-markup-with-jsx#the-rules-of-jsx
///

Другими словами, императивное программирование похоже на 
пошаговые инструкции шеф-повара по приготовлению пиццы. Декларативное программирование 
похоже на заказ пиццы, не заботясь о шагах, необходимых для ее приготовления. 
///

Пропсы (объект): передаются через аргумент функции(компонента) при рендере.
Передача идёт от родительского элемента к дочернему. (Проблема решается с помощью функции
обратного вызова(callback))
Пропсы можно только читать.

props.children - вложенные элементы.
///

Чистые функции - это функции, которые не меняют свои входные данные и предсказуемо возвращают
один и тот же результат для одинаковых аргументов.
///

Разделение на компоненты при сложности и повторении.
///

React-компоненты обязаны вести себя как чистые функции по отношению к своим пропсам.
///

Отличие СОСТОЯНИЯ от ПРОПСОВ: состояние контролируется и доступно только конкретному компоненту.
//

Преобразование функционального компонента в классовый.
super(props) - передача аргумента(props) базовому(родительскому) конструктору.

//
В приложениях со множеством компонентво важно освобождать используемые системные ресурсы после
удаления компонентов.
Первоначальный рендеринг компонента - монтирование.
Когда удаляется дом-узел созданный компонентом происходит размонтирование.

 Методы жизненного цикла:   componentDidMount() {}
    				      componentWillUnmount() {}

//
Состояние - useState(). Два параметра(значение и функция).
Двустороннее связывание - связывание текста с значением инпута.
Управляемые компоненты - возможность изменить значения компонента, изменив состояние.
В классовом компоненте хуки использовать запрещено.
напрямую вызывать нельзя (this.state.count), нужно вызвать функцию (setState()).

//
Основные хуки: useState(), useEffect(), useRef(), useMemo(), useCallback(), useContext().
Управляемый компонент - это компонент, который визуализирует элементы формы и управляет ими, 
сохраняя данные формы в состоянии компонента.

useRef() - Позволяет работать с DOM-elements. указывается пропс ref в атрибутах. Передаёт значение input.
	React.forwardRef - функция для указания ссылки для передачи value.

функция prev в useState() - если нужно изменять предидущее значение. useState(10) - 1.
Ошибка с undefined при первом рендере. Нужно хранить по default какой-то объект в useState()
Хранить данные в useState() только если они будут меняться.

useMemo(callback, deps) - 1 параметр(результат каких-то вычислений), 2 параметр(массив зависимостей. Можно передавать
переменные, поля объекта и т.п.). В этом хуке воспроизводится мемоизация, данные вычисляются, затем они запоминаются и
кэшируются, заново массив она не сортирует, достаёт массив из кэша. Если одна из зависимостей изменятся(2 параметр), то
функция опять кэширует до тех пор, пока не изменится 1 из зависимостей.

useEffect() - принимает параметры как и useMemo(). Когда массив зависимостей пустой - callback, который мы передаём
в useEffect() отработает 1 раз.

Хуки можно использовать только на верхнем уровне вложенности.(Нельзя вложить в циклы, функции и тд).

//
Ключи позволяют реакту эффективно делать рендеринг перерисовывать только те значения, которые изменились.