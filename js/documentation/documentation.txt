Object - определённый тип. 
//

Операторы: 
Spread: ... Разворачивает массив, объеденение, работа с obj - как и с масс, но в {}
Порядок имеет значение. Math.max(...mas);
Rest: Собирает оставшиеся аргументы в новый массив. 
const [a, b, ...other] = numbers; //1,2 [3, 4, 5]

Унарный: меняет число на противоположное.

Опциональная цепочка. Нужна для предотвращения ошибки при обращении
к незаданному значению свойства объекта. (например: user не ввёл email)
?. В querySelector перед innerHTML
?.(), ?.[] -  возвращает, иначе undefined
//

Функции: 
Function Expression - через переменную.
Function declaration - function name() {}.

Функции в свойствах объекта - методы.

Функция-конструктор: User()
function Ads(name) {
   this.name = name;
}	
let t = Ads("Elon");
console.log(t.name);
Мы можем использовать конструкторы для создания множества похожих объектов.

Примитив - данные которые не являются объектом и не имеют методов.
Есть 7 примитивных типов: string, number, boolean, symbol, null, 
undefined и bigint
//

Литерал - всё, что в {}

//

Symbol - примитивный тип данных, использующийся для создания
уникальных идентификаторов.
пример: добавление в объект id user'a.
Сторонний код захочет внести свой id в мой object
Сторонний код может создать для этого свой символ Symbol("id");
Конфликта между их и нашим идентификатором не будет, так как символы всегда уникальны, 
даже если их имена совпадают.
//

Преобразование объектов в примитивы нужно для действий над ними.
Ведь объекты не являются примитивами.
//

Явное указание this: call, apply.
func.call(context, arg1, arg2, ...)
Может передаваться объект в context
https://learn.javascript.ru/call-apply
//

Замыкание: Способность функции обращаться к внешней области видимости
(функция внутри другой функции, имеет доступ к полям функции).
//

Оператор нулевого слияния: Если значение не определено. (??)
let name = null;
//

Преобразование примитивы. К объем редко применяются мат. операции.
Исключение к примеру: Объект date.
Преобразование типов называется "Хинтами".
//

Массивы:
Деструктуризация - синтаксис присваивания, при котором можно присвоить массив или объект
сразу нескольким переменным, разбив его на части.

Вместо: sum = res[0]; sub = res[1]; Деструктуризация: const [sum, sub] = res;

Методы массива:
arr.push(...items) – добавляет элементы в конец,
arr.pop() – извлекает элемент из конца,
arr.shift() – извлекает элемент из начала,
arr.unshift(...items) – добавляет элементы в начало.

find
найти определённый id в объекте:
	item.find(item => item.id == 1);

splice, slice, concat, indexOf/lastIndexOf/include, map,
sort(fn), reverse, split, join, reduce/reduceRight, array/isarray

bind - нужен для вызова нужного контекста.
bind возвращает функцию, а call сразу её вызывает.
в apply доп. параметры передаются массивом.
    const numbers = [2, 9, 3, 15];
    console.log(Math.max.apply(null, numbers));

map - получение нового массива преобразовав все элементы. const people = [{name=, age=}]; people.map(person => person.name);
filter - 
findIndex - 
reduce - удобное сложение элементов. people.reduce((total, person) => total + person.budget, 0)
//

//
Прототипы

//
CallBack - функция, которая выполняется после того, как другая функция завршила выполнение.

Асинхронный JS: Воркеры для создания нескольких потоков. Т.е. для запуска
нескольких задач одновременно. В основном использование воркеров, чтобы запустить отдельно
ресурсоёмкий процесс без блокировки действий пользователя.

Воркеры не имеют доступа к DOM. Они могут только обрабатывать информацию.

Если к примеру картинка ещё не загружена, но процессы с действиями на ней уже запущены, то они
завершаются ошибкой. Браузер позволяет запускать определённые задачи асинхронно.
Промисы позволяют к примеру получить картинку с сервера и подождать пока она не вернёт результат,
перед тем как начать выполнение другой задачи.
//

SUPER() - для вызова конструктора родительского класса.

Синхронный - один поток. Асинхронный - несколько потоков.

2 типа асинхронного кода: Callbacks and Promises(NEWER).
Асинхронный колбэк - функция, определяется как аргумент. Оповещает, что работа завершена.(картинка загружена)

script.onload - срабатывает после того, как скрипт был загружен и выполнен.

Промисы - более новый способ, используется в современных WebApi. Пример fetch().
Новее и эффективнее, чем XMLHttpRequest().
Промис - объект представляющий асинхронную операцию, выполненную удачно/неудачно.(обещание возврата ответа).

//
Socket - связь между клиентской и серверной программой.